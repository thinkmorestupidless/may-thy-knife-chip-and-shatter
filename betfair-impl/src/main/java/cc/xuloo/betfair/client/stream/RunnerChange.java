/**
 * Betfair: Exchange Streaming API
 * API to receive streamed updates. This is an ssl socket connection of CRLF delimited json messages (see RequestMessage & ResponseMessage)
 *
 * OpenAPI spec version: 1.0.1423
 * Contact: bdp@betfair.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package cc.xuloo.betfair.client.stream;

import cc.xuloo.betfair.client.exchange.entities.Runner;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Value;
import org.assertj.core.util.Lists;

import java.util.Collections;
import java.util.List;


/**
 * RunnerChange
 */
@Value
public class RunnerChange   {

    public static RunnerChange empty() {
        return new RunnerChange(
                null,
                Collections.emptyList(),
                Collections.emptyList(),
                Collections.emptyList(),
                Collections.emptyList(),
                null,
                null,
                Collections.emptyList(),
                Collections.emptyList(),
                null,
                Collections.emptyList(),
                Collections.emptyList(),
                null,
                null,
                Collections.emptyList());
    }

    /**
    * The total amount matched. This value is truncated at 2dp.
    * @return tv
    **/
    private final Double tv;

    /**
    * Best Available To Back - LevelPriceVol triple delta of price changes, keyed by level (0 vol is remove)
    * @return batb
    **/
    private final List<List<Double>> batb;

    /**
     * Starting Price Back - PriceVol tuple delta of price changes (0 vol is remove)
     * @return spb
     **/
    private final List<List<Double>> spb;

    /**
     * Best Display Available To Lay (includes virtual prices)- LevelPriceVol triple delta of price changes, keyed by level (0 vol is remove)
     * @return bdatl
     **/
    private final List<List<Double>> bdatl;

    /**
     * Traded - PriceVol tuple delta of price changes (0 vol is remove)
     * @return trd
     **/
    private final List<List<Double>> trd;

    /**
     * Starting Price Far - The far starting price (or null if un-changed)
     * @return spf
     **/
    private final Double spf;

    /**
     * Last Traded Price - The last traded price (or null if un-changed)
     * @return ltp
     **/
    private final Double ltp;

    /**
     * Available To Back - PriceVol tuple delta of price changes (0 vol is remove)
     * @return atb
     **/
    private final List<List<Double>> atb;

    /**
     * Starting Price Lay - PriceVol tuple delta of price changes (0 vol is remove)
     * @return spl
     **/
    private final List<List<Double>> spl;

    /**
     * Starting Price Near - The far starting price (or null if un-changed)
     * @return spn
     **/
    private final Double spn;

    /**
     * Available To Lay - PriceVol tuple delta of price changes (0 vol is remove)
     * @return atl
     **/
    private final List<List<Double>> atl;

    /**
     * Best Available To Lay - LevelPriceVol triple delta of price changes, keyed by level (0 vol is remove)
     * @return batl
     **/
    private final List<List<Double>> batl;

    /**
     * Selection Id - the id of the runner (selection)
     * @return id
     **/
    private final Long id;

    /**
     * Handicap - the handicap of the runner (selection) (null if not applicable)
     * @return hc
     **/
    private final Double hc;

    /**
     * Best Display Available To Back (includes virtual prices)- LevelPriceVol triple delta of price changes, keyed by level (0 vol is remove)
     * @return bdatb
     **/
    private final List<List<Double>> bdatb;

    public RunnerChange(@JsonProperty("tv") Double tv,
                        @JsonProperty("batb") List<List<Double>> batb,
                        @JsonProperty("spb") List<List<Double>> spb,
                        @JsonProperty("bdatl") List<List<Double>> bdatl,
                        @JsonProperty("trd") List<List<Double>> trd,
                        @JsonProperty("spf") Double spf,
                        @JsonProperty("ltp") Double ltp,
                        @JsonProperty("atb") List<List<Double>> atb,
                        @JsonProperty("spl") List<List<Double>> spl,
                        @JsonProperty("spn") Double spn,
                        @JsonProperty("atl") List<List<Double>> atl,
                        @JsonProperty("batl") List<List<Double>> batl,
                        @JsonProperty("id") Long id,
                        @JsonProperty("hc") Double hc,
                        @JsonProperty("bdatb") List<List<Double>> bdatb) {
        this.tv = tv;
        this.batb = batb;
        this.spb = spb;
        this.bdatl = bdatl;
        this.trd = trd;
        this.spf = spf;
        this.ltp = ltp;
        this.atb = atb;
        this.spl = spl;
        this.spn = spn;
        this.atl = atl;
        this.batl = batl;
        this.id = id;
        this.hc = hc;
        this.bdatb = bdatb;
    }

    public RunnerChange merge(RunnerChange other) {
        Double tv = other.getTv() == null ? getTv() : other.getTv();
        Double spf = other.getSpf() == null ? getSpf() : other.getSpf();
        Double ltp = other.getLtp() == null ? getLtp() : other.getLtp();
        Double spn = other.getSpn() == null ? getSpn() : other.getSpn();
        Double hc = other.getHc() == null ? getHc() : other.getHc();

        List<List<Double>> batb = merge(getBatb(), other.getBatb(), 2);
        List<List<Double>> batl = merge(getBatl(), other.getBatl(), 2);
        List<List<Double>> bdatb = merge(getBdatb(), other.getBdatb(), 2);
        List<List<Double>> bdatl = merge(getBdatl(), other.getBdatl(), 2);

        List<List<Double>> atb = merge(getAtb(), other.getAtb(), 1);
        List<List<Double>> atl = merge(getAtl(), other.getAtl(), 1);
        List<List<Double>> spb = merge(getSpb(), other.getSpb(), 1);
        List<List<Double>> spl = merge(getSpl(), other.getSpl(), 1);
        List<List<Double>> trd = merge(getTrd(), other.getTrd(), 1);

        return new RunnerChange(tv, getBatb(), getSpb(), getBdatl(), getTrd(), spf, ltp, getAtb(), getSpl(), spn, getAtl(), getBatl(), getId(), getHc(), getBdatb());
    }

    public List<List<Double>> merge(List<List<Double>> a, List<List<Double>> b, int removeIndex) {
        if (b == null) {
            return a;
        }

        List<List<Double>> list = Lists.newArrayList();

        for (List<Double> aEntry : a) {
            List<Double> replacement = null;

            for (List<Double> bEntry : b) {

                if (aEntry.get(0).equals(bEntry.get(0))) {
                    replacement = bEntry;
                }
            }

            if (replacement == null) {
                list.add(aEntry);
            } else if (replacement.get(removeIndex) > 0.001) {
                list.add(replacement);
            }
        }

        return list;
    }
}

